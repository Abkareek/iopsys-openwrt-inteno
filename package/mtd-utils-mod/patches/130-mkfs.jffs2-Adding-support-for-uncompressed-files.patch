From 6af2a742db5e072944417313faefbe0c8041942a Mon Sep 17 00:00:00 2001
From: Benjamin Larsson <benjamin@southpole.se>
Date: Fri, 17 Apr 2015 10:55:17 +0200
Subject: [PATCH 1/3] mkfs.jffs2: Adding support for uncompressed files

---
 mkfs.jffs2.c | 75 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 73 insertions(+), 2 deletions(-)

diff --git a/mkfs.jffs2.c b/mkfs.jffs2.c
index f09c0b2..3e63900 100644
--- a/mkfs.jffs2.c
+++ b/mkfs.jffs2.c
@@ -110,6 +110,8 @@ static int squash_uids = 0;
 static int squash_perms = 0;
 static int fake_times = 0;
 int target_endian = __BYTE_ORDER;
+static char default_compression_name[16] = "priority";
+static char donotcompress_filelist[256] = "";
 
 uint32_t find_hardlink(struct filesystem_entry *e)
 {
@@ -607,10 +609,23 @@ static int pad_fs_size = 0;
 static int add_cleanmarkers = 1;
 static struct jffs2_unknown_node cleanmarker;
 static int cleanmarker_size = sizeof(cleanmarker);
+#if 1 /* CONFIG_MIPS_BRCM */
+/* Pad with 0x00 which is JFFS2_DIRTY_BITMASK rather than 0xff in order to
+ * prevent "Empty flash at 0xXXXXXXXX ends at 0xYYYYYYYY" JFFS2 messages
+ * from displaying during the kernel boot.  This message displays if the
+ * block size passed to this utility (-e) is less than the actual flash
+ * chip block size.
+ */
+static unsigned char ffbuf[16] =
+{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00
+};
+#else
 static unsigned char ffbuf[16] =
 { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 	0xff, 0xff, 0xff, 0xff, 0xff
 };
+#endif
 
 /* We set this at start of main() using sysconf(), -1 means we don't know */
 /* When building an fs for non-native systems, use --pagesize=SIZE option */
@@ -717,6 +732,31 @@ static void write_dirent(struct filesystem_entry *e)
 	padword();
 }
 
+static int do_not_compress(char *name)
+{
+	int ret = 0;
+	if( donotcompress_filelist[0] != '\0' )
+	{
+		char filename[256];
+		FILE *fp = xfopen(donotcompress_filelist, "r");
+
+		while( fgets(filename, sizeof(filename), fp) )
+		{
+			filename[strlen(filename) - 1] = '\0';
+			if( !strcmp(name, filename) )
+			{
+				printf("not compressing file, %s\n", name);
+				ret = 1;
+				break;
+			}
+		}
+
+		fclose(fp);
+	}
+
+	return( ret );
+}
+
 static unsigned int write_regular_file(struct filesystem_entry *e)
 {
 	int fd, len;
@@ -762,6 +802,9 @@ static unsigned int write_regular_file(struct filesystem_entry *e)
 	ri.mtime = cpu_to_je32(statbuf->st_mtime);
 	ri.isize = cpu_to_je32(statbuf->st_size);
 
+	if( do_not_compress(e->fullname) )
+		jffs2_set_compression_mode_name("none");
+
 	while ((len = read(fd, buf, page_size))) {
 		unsigned char *tbuf = buf;
 
@@ -839,6 +882,9 @@ static unsigned int write_regular_file(struct filesystem_entry *e)
 	}
 	free(buf);
 	close(fd);
+
+	jffs2_set_compression_mode_name(default_compression_name);
+
 	return totcomp;
 }
 
@@ -1320,6 +1366,8 @@ static void recursive_populate_directory(struct filesystem_entry *dir)
 
 static void create_target_filesystem(struct filesystem_entry *root)
 {
+	static int amt_left = 0;
+
 	cleanmarker.magic    = cpu_to_je16(JFFS2_MAGIC_BITMASK);
 	cleanmarker.nodetype = cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER);
 	cleanmarker.totlen   = cpu_to_je32(cleanmarker_size);
@@ -1331,6 +1379,23 @@ static void create_target_filesystem(struct filesystem_entry *root)
 	root->ino = 1;
 	recursive_populate_directory(root);
 
+	if (pad_fs_size == -1 || (pad_fs_size && add_cleanmarkers))
+		amt_left = erase_block_size - (out_ofs % erase_block_size);
+	else
+		amt_left = pad_fs_size - (out_ofs % pad_fs_size);
+
+	if (amt_left > sizeof(struct jffs2_unknown_node)) {
+
+		struct jffs2_unknown_node un;
+
+		un.magic    = cpu_to_je16(JFFS2_MAGIC_BITMASK);
+		un.nodetype = cpu_to_je16(JFFS2_NODETYPE_PADDING);
+		un.totlen   = cpu_to_je32(amt_left);
+		un.hdr_crc  = cpu_to_je32(mtd_crc32(0, &un, sizeof(struct jffs2_unknown_node)-4));
+
+		full_write(out_fd, &un, sizeof(un));
+	}
+
 	if (pad_fs_size == -1) {
 		padblock();
 	} else {
@@ -1379,6 +1444,7 @@ static struct option long_options[] = {
 	{"with-selinux", 0, NULL, 1001 },
 	{"with-posix-acl", 0, NULL, 1002 },
 #endif
+	{"donotcompress-filelist", 1, NULL, 'N'},
 	{NULL, 0, NULL, 0}
 };
 
@@ -1421,7 +1487,8 @@ static const char helptext[] =
 "  -h, --help              Display this help text\n"
 "  -v, --verbose           Verbose operation\n"
 "  -V, --version           Display version information\n"
-"  -i, --incremental=FILE  Parse FILE and generate appendage output for it\n\n";
+"  -i, --incremental=FILE  Parse FILE and generate appendage output for it\n"
+"  -N, --donotcompress-filelist=FILE  Do not compress files in FILE\n\n";
 
 static const char revtext[] = "1.60";
 
@@ -1574,7 +1641,7 @@ int main(int argc, char **argv)
 	jffs2_compressors_init();
 
 	while ((opt = getopt_long(argc, argv,
-					"D:d:r:s:o:qUPfh?vVe:lbp::nc:m:x:X:Lty:i:", long_options, &c)) >= 0)
+			"D:d:r:s:o:qUPfh?vVe:lbp::nc:m:x:X:Lty:i:N:", long_options, &c)) >= 0)
 	{
 		switch (opt) {
 			case 'D':
@@ -1698,6 +1765,7 @@ int main(int argc, char **argv)
 					  if (jffs2_set_compression_mode_name(optarg)) {
 						  errmsg_die("Unknown compression mode %s", optarg);
 					  }
+					  strcpy(default_compression_name, optarg);
 					  break;
 			case 'x':
 					  if (jffs2_disable_compressor_name(optarg)) {
@@ -1752,6 +1820,9 @@ int main(int argc, char **argv)
 						  | (1 << JFFS2_XPREFIX_ACL_DEFAULT);
 					  break;
 #endif
+			case 'N':
+					  strcpy(donotcompress_filelist, optarg);
+					  break;
 		}
 	}
 	if (warn_page_size) {
-- 
1.9.1

