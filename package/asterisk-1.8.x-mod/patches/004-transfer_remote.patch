--- a/channels/chan_brcm.c
+++ b/channels/chan_brcm.c
@@ -111,6 +111,9 @@ struct sched_context *sched; // Scheduli
 /* Call waiting */
 static int cwtimeout = DEFAULT_CALL_WAITING_TIMEOUT;
 
+/* R4 transfer */
+static int r4hanguptimeout = DEFAULT_R4_HANGUP_TIMEOUT;
+
 /* Maximum allowed delay between early on and early off hook for detecting hookflash */
 static int hfmaxdelay = DEFAULT_MAX_HOOKFLASH_DELAY;
 
@@ -192,6 +195,7 @@ AST_MUTEX_DEFINE_STATIC(ioctl_lock);
 
 static int load_settings(struct ast_config **cfg);
 static void load_endpoint_settings(struct ast_config *cfg);
+static char *state2str(enum channel_state state);
 
 /* exported capabilities */
 static const struct ast_channel_tech brcm_tech = {
@@ -221,6 +225,19 @@ static int brcm_indicate(struct ast_chan
 		//This is a workaround until jitter buffer is handled by DSP.
 		ast_jb_destroy(sub->owner);
 		break;
+	case AST_CONTROL_RINGING:
+		brcm_subchannel_set_state(sub, RINGBACK);
+		res = 1; //We still want asterisk core to play tone
+		break;
+	case AST_CONTROL_TRANSFER:
+		res = -1;
+		if (datalen != sizeof(enum ast_control_transfer)) {
+			ast_log(LOG_ERROR, "Invalid datalen for AST_CONTROL_TRANSFER. Expected %d, got %d\n", (int) sizeof(enum ast_control_transfer), (int) datalen);
+		} else {
+			enum ast_control_transfer *message = data;
+			brcm_finish_transfer(sub, *message);
+		}
+		break;
 	default:
 		res = -1;
 		break;
@@ -229,6 +246,64 @@ static int brcm_indicate(struct ast_chan
 	return res;
 }
 
+static int brcm_finish_transfer(struct brcm_subchannel *p, int result)
+{
+	struct brcm_subchannel* peer_sub;
+	/*
+	 * We have received the result of a transfer operation.
+	 * This could be:
+	 * - Result of a Transfer-On-Hangup (Remote Transfer), in which case
+	 *   we should hangup the subchannel, no matter the result
+	 * - Result of a R4 Attended Transfer (Remote Transfer), in which case
+	 *   we should wait for hangup on both subchannels, or resume calls if failed
+	 *   Hangup should be received immediately, but we start a timer to hangup
+	 *   everythin ourselfs just to be sure.
+	 * - Probably nothing else - the builtin transfer should never let this
+	 *   control frame propagate to here
+	 */
+
+	if (p->channel_state != TRANSFERING) {
+		ast_log(LOG_WARNING, "Received AST_CONTROL_TRANSFER while in state %s\n", state2str(p->channel_state));
+		return -1;
+	}
+
+	peer_sub = brcm_subchannel_get_peer(p);
+	if (!peer_sub) {
+		ast_log(LOG_ERROR, "Failed to get peer subchannel\n");
+		return -1;
+	}
+
+	// In the case of Transfer-On-Hangup peer sub should be a idle
+	if (brcm_subchannel_is_idle(peer_sub)) {
+		if (result == AST_TRANSFER_SUCCESS) {
+			ast_log(LOG_NOTICE, "Remote transfer completed successfully, hanging up\n");
+		}
+		else {
+			ast_log(LOG_NOTICE, "Remote transfer failed, hanging up\n");
+		}
+
+		ast_queue_control(p->owner, AST_CONTROL_HANGUP);
+		brcm_subchannel_set_state(p, CALLENDED);
+
+	// In the case of R4 transfer peer sub should be on hold
+	} else if (peer_sub->channel_state == ONHOLD) {
+		if (result == AST_TRANSFER_SUCCESS) {
+			ast_log(LOG_NOTICE, "Remote transfer completed successfully, wait for remote hangup\n");
+			p->r4_hangup_timer_id = ast_sched_add(sched, r4hanguptimeout, r4hanguptimeout_cb, p);
+		} else {
+			//Do nothing. Let calls be up as they were before R4 was attempted (first call on hold, second call active)
+			ast_log(LOG_NOTICE, "Remote transfer failed\n");
+			brcm_subchannel_set_state(p, INCALL);
+		}
+
+	} else {
+		ast_log(LOG_WARNING, "AST_CONTROL_TRANSFER received in unexpected state\n");
+		return -1;
+	}
+
+	return 0;
+}
+
 static int brcm_senddigit_begin(struct ast_channel *ast, char digit)
 {
 	int res;
@@ -324,7 +399,7 @@ static int brcm_call(struct ast_channel
 		brcm_subchannel_set_state(sub, CALLWAITING);
 		brcm_signal_callwaiting(p);
 		int cwtimeout_ms = cwtimeout * 1000;
-		sub->timer_id = ast_sched_add(sched, cwtimeout_ms, cwtimeout_cb, sub);
+		sub->cw_timer_id = ast_sched_add(sched, cwtimeout_ms, cwtimeout_cb, sub);
 	} else {
 		ast_log(LOG_WARNING, "Not call waiting\n");
 		brcm_subchannel_set_state(sub, RINGING);
@@ -367,10 +442,10 @@ static int brcm_hangup(struct ast_channe
 	if (sub->channel_state == CALLWAITING) {
 		ast_log(LOG_DEBUG, "stop Call waiting\n");
 		brcm_stop_callwaiting(p);
-		if (ast_sched_del(sched, sub->timer_id)) {
+		if (ast_sched_del(sched, sub->cw_timer_id)) {
 			ast_log(LOG_WARNING, "Failed to remove scheduled call waiting timer");
 		}
-		sub->timer_id = -1;
+		sub->cw_timer_id = -1;
 	} else {
 		ast_log(LOG_DEBUG, "Not call waiting\n");
 		if (!clip) {
@@ -379,6 +454,13 @@ static int brcm_hangup(struct ast_channe
 			brcm_stop_ringing_callerid_pending(p);
 		}
 	}
+
+	if(sub->r4_hangup_timer_id != -1) {
+		if (ast_sched_del(sched, sub->r4_hangup_timer_id)) {
+			ast_log(LOG_WARNING, "Failed to remove scheduled r4 hangup timer");
+		}
+		sub->r4_hangup_timer_id = -1;
+	}
 	ast_setstate(ast, AST_STATE_DOWN);
 
 	p->lastformat = -1;
@@ -648,10 +730,27 @@ static char *state2str(enum channel_stat
 	case RINGING:		return "RINGING";
 	case CALLWAITING:	return "CALLWAITING";
 	case ONHOLD:		return "ONHOLD";
+	case TRANSFERING:	return "TRANSFERING";
+	case RINGBACK:		return "RINGBACK";
 	default:			return "UNKNOWN";
 	}
 }
 
+static int brcm_subchannel_is_idle(const struct brcm_subchannel const * const sub)
+{
+	if (sub->channel_state == ONHOOK || sub->channel_state == CALLENDED) {
+		return 1;
+	}
+	return 0;
+}
+
+static struct brcm_subchannel *brcm_subchannel_get_peer(const struct brcm_subchannel const * const sub)
+{
+	struct brcm_subchannel *peer_sub;
+	peer_sub = sub->parent->sub[0] == sub ? sub->parent->sub[1] : sub->parent->sub[0];
+	return peer_sub;
+}
+
 /*
  * Set sub channel state and send manager event.
  * Assume parent lock is held.
@@ -805,6 +904,8 @@ struct brcm_subchannel* brcm_get_active_
 			case CALLING:
 			case OFFHOOK:
 			case RINGING:
+			case TRANSFERING:
+			case RINGBACK:
 				sub = p->sub[i];
 				return sub;
 			case CALLWAITING:
@@ -861,7 +962,7 @@ static int cwtimeout_cb(const void *data
 
 	sub = (struct brcm_subchannel *) data;
 	ast_mutex_lock(&sub->parent->lock);
-	sub->timer_id = -1;
+	sub->cw_timer_id = -1;
 	sub->owner->hangupcause = AST_CAUSE_USER_BUSY;
 	ast_queue_control(sub->owner, AST_CONTROL_BUSY);
 	ast_mutex_unlock(&sub->parent->lock);
@@ -869,6 +970,33 @@ static int cwtimeout_cb(const void *data
 	return 0;
 }
 
+/* Hangup calls if not done by remote after R4 transfer */
+static int r4hanguptimeout_cb(const void *data)
+{
+	struct brcm_subchannel *sub;
+	struct brcm_subchannel *peer_sub;
+
+	ast_log(LOG_DEBUG, "No hangup from remote after remote transfer using R4, hanging up\n");
+
+	sub = (struct brcm_subchannel *) data;
+	ast_mutex_lock(&sub->parent->lock);
+	sub->r4_hangup_timer_id = -1;
+	if (sub->owner) {
+		ast_queue_control(sub->owner, AST_CONTROL_HANGUP);
+	}
+	peer_sub = brcm_subchannel_get_peer(sub);
+	if (peer_sub) {
+		if (peer_sub->owner) {
+			ast_queue_control(peer_sub->owner, AST_CONTROL_HANGUP);
+		}
+		brcm_subchannel_set_state(peer_sub, CALLENDED);
+	}
+	brcm_subchannel_set_state(sub, CALLENDED);
+	ast_mutex_unlock(&sub->parent->lock);
+
+	return 0;
+}
+
 /*
  * Helper function that tells asterisk to start a call on the provided pvt/sub/context
  * using the content of the dtmf buffer.
@@ -1100,10 +1228,10 @@ static void handle_hookflash(struct brcm
 					ast_log(LOG_WARNING, "Failed to get vall waiting subchannel\n");
 					break;
 				}
-				if (ast_sched_del(sched, sub->timer_id)) {
+				if (ast_sched_del(sched, sub->cw_timer_id)) {
 					ast_log(LOG_WARNING, "Failed to remove scheduled call waiting timer\n");
 				}
-				sub->timer_id = -1;
+				sub->cw_timer_id = -1;
 
 				sub->owner->hangupcause = AST_CAUSE_USER_BUSY;
 				ast_queue_control(sub->owner, AST_CONTROL_BUSY);
@@ -1139,10 +1267,10 @@ static void handle_hookflash(struct brcm
 						ast_log(LOG_WARNING, "Failed to get call waiting subchannel\n");
 						break;
 					}
-					if (ast_sched_del(sched, sub->timer_id)) {
+					if (ast_sched_del(sched, sub->cw_timer_id)) {
 						ast_log(LOG_WARNING, "Failed to remove scheduled call waiting timer\n");
 					}
-					sub->timer_id = -1;
+					sub->cw_timer_id = -1;
 
 					/* Pick up call waiting */
 					if (!sub->connection_init) {
@@ -1199,10 +1327,10 @@ static void handle_hookflash(struct brcm
 						ast_log(LOG_WARNING, "Failed to get call waiting subchannel\n");
 						break;
 					}
-					if (ast_sched_del(sched, sub->timer_id)) {
+					if (ast_sched_del(sched, sub->cw_timer_id)) {
 						ast_log(LOG_WARNING, "Failed to remove scheduled call waiting timer\n");
 					}
-					sub->timer_id = -1;
+					sub->cw_timer_id = -1;
 
 					/* Pick up call waiting */
 					if (!sub->connection_init) {
@@ -1270,6 +1398,38 @@ static void handle_hookflash(struct brcm
 			}
 			break;
 
+		/* Remote transfer held call to active call */
+		case '4':
+			ast_log(LOG_DEBUG, "R4 Transfer\n");
+			if (brcm_in_call(p) && brcm_in_onhold(p)) {
+
+				active_sub = brcm_get_active_subchannel(p);
+				if (active_sub && active_sub->owner) {
+
+					struct ast_channel *bridged_chan;
+					struct ast_transfer_remote_data data;
+					sub = brcm_subchannel_get_peer(active_sub);
+
+					if (sub && sub->owner) {
+						bridged_chan = ast_bridged_channel(sub->owner);
+						if (bridged_chan) {
+							ast_verbose("Performing R4 transfer to %s, replacing call on %s\n", active_sub->parent->ext, bridged_chan->name);
+
+							strcpy(data.exten, active_sub->parent->ext);
+							strcpy(data.replaces, bridged_chan->name);
+
+							ast_queue_control_data(active_sub->owner, AST_CONTROL_TRANSFER_REMOTE, &data, sizeof(data));
+							brcm_subchannel_set_state(active_sub, TRANSFERING);
+						} else {
+							ast_log(LOG_ERROR, "Failed to fetch bridged channel\n");
+						}
+					} else {
+						ast_log(LOG_ERROR, "Failed to fetch peer sub or peer sub had no owner\n");
+					}
+				}
+			}
+			break;
+
 		default:
 			ast_log(LOG_NOTICE, "Unhandled DTMF %c\n", p->dtmfbuf[0]);
 			break;
@@ -1582,10 +1742,17 @@ static void *brcm_monitor_events(void *d
 				gettimeofday(&tim, NULL);
 				p->last_dtmf_ts = tim.tv_sec*TIMEMSEC + tim.tv_usec/TIMEMSEC;
 
+				int perform_remote_transfer = 0;
+
 				if (sub->channel_state == OFFHOOK) {
 					/* Received EPEVT_ONHOOK in state OFFHOOK, stop dialtone */
 					brcm_stop_dialtone(p);
 				}
+				else if (sub->channel_state == RINGBACK) {
+					line_settings *s = &line_config[sub->parent->line_id];
+					ast_log(LOG_DEBUG, "Semi-attended transfer active\n");
+					perform_remote_transfer = s->hangup_xfer;
+				}
 
 				brcm_subchannel_set_state(sub, ONHOOK);
 				ast_verbose("Sending manager event\n");
@@ -1602,13 +1769,30 @@ static void *brcm_monitor_events(void *d
 					ast_queue_control(sub->owner, AST_CONTROL_HANGUP);
 				}
 
-				/* Hangup peer subchannels in call, on hold or in call waiting */
 				struct brcm_subchannel *peer_sub;
+				//TRANSFER_REMOTE
+				if (perform_remote_transfer) {
+					peer_sub = brcm_get_onhold_subchannel(sub->parent);
+					if (peer_sub && peer_sub->owner) {
+						ast_verbose("Performing transfer-on-hangup to %s\n", peer_sub->parent->ext);
+
+						struct ast_transfer_remote_data data;
+						strcpy(data.exten, peer_sub->parent->ext);
+						data.replaces[0] = '\0'; //Not replacing any call
+
+						ast_queue_control_data(peer_sub->owner, AST_CONTROL_TRANSFER_REMOTE, &data, sizeof(data));
+						brcm_subchannel_set_state(peer_sub, TRANSFERING);
+					}
+				}
+
+				//TODO: possible bug below - we don't change the channel_state when hanging up
+
+				/* Hangup peer subchannels in call, on hold or in call waiting */
 				if ((peer_sub = brcm_get_callwaiting_subchannel(sub->parent)) != NULL) {
-					if (ast_sched_del(sched, peer_sub->timer_id)) {
+					if (ast_sched_del(sched, peer_sub->cw_timer_id)) {
 						ast_log(LOG_WARNING, "Failed to remove scheduled call waiting timer\n");
 					}
-					peer_sub->timer_id = -1;
+					peer_sub->cw_timer_id = -1;
 
 					if (peer_sub->owner) {
 						peer_sub->owner->hangupcause = AST_CAUSE_USER_BUSY;
@@ -1616,9 +1800,11 @@ static void *brcm_monitor_events(void *d
 					}
 				}
 				if ((peer_sub = brcm_get_onhold_subchannel(sub->parent)) != NULL || (peer_sub = brcm_get_active_subchannel(sub->parent)) != NULL) {
-					ast_log(LOG_DEBUG, "should hangup call on hold or incall\n");
-					if (peer_sub->owner) {
-						ast_queue_control(peer_sub->owner, AST_CONTROL_HANGUP);
+					if (peer_sub->channel_state != TRANSFERING) {
+						ast_log(LOG_DEBUG, "should hangup call on hold or incall\n");
+						if (peer_sub->owner) {
+							ast_queue_control(peer_sub->owner, AST_CONTROL_HANGUP);
+						}
 					}
 				}
 				break;
@@ -1812,7 +1998,8 @@ static struct brcm_pvt *brcm_allocate_pv
 				sub->ssrc = 0;
 				sub->codec = -1;
 				sub->parent = tmp;
-				sub->timer_id = -1;
+				sub->cw_timer_id = -1;
+				sub->r4_hangup_timer_id = -1;
 				tmp->sub[i] = sub;
 				ast_log(LOG_DEBUG, "subchannel created\n");
 			} else {
@@ -2099,7 +2286,8 @@ static void brcm_show_subchannels(struct
 		ast_cli(a->fd, "  RTP sequence number : %d\n", sub->sequence_number);
 		ast_cli(a->fd, "  RTP SSRC            : %d\n", sub->ssrc);
 		ast_cli(a->fd, "  RTP timestamp       : %d\n", sub->time_stamp);
-		ast_cli(a->fd, "  Timer id            : %d\n", sub->timer_id);
+		ast_cli(a->fd, "  CW Timer id         : %d\n", sub->cw_timer_id);
+		ast_cli(a->fd, "  R4 Hangup Timer id  : %d\n", sub->r4_hangup_timer_id);
 	}
 }
 
@@ -2830,6 +3018,7 @@ static line_settings line_settings_creat
 		.jitterMin = 0,
 		.jitterMax = 0,
 		.jitterTarget = 0,
+		.hangup_xfer = 0,
 	};
 	return line_conf;
 }
@@ -2950,6 +3139,9 @@ static void line_settings_load(line_sett
 		else if (!strcasecmp(v->name, "jitter_target")) {
 			line_config->jitterTarget = strtoul(v->value, NULL, 0);
 		}
+		else if (!strcasecmp(v->name, "hangup_xfer")) {
+			line_config->hangup_xfer = ast_true(v->value)?1:0;
+		}
 
 		if (config_codecs > 0)
 			line_config->codec_nr = config_codecs;
@@ -3008,7 +3200,7 @@ static int load_settings(struct ast_conf
 			cwtimeout = atoi(v->value);
 			if (cwtimeout > 60 || cwtimeout < 0) {
 				cwtimeout = DEFAULT_CALL_WAITING_TIMEOUT;
-				ast_log(LOG_WARNING, "Incorrect cwtimeouty '%s', defaulting to '%d'\n", v->value, cwtimeout);
+				ast_log(LOG_WARNING, "Incorrect cwtimeout '%s', defaulting to '%d'\n", v->value, cwtimeout);
 			}
 		} else if (!strcasecmp(v->name, "hfmaxdelay")) {
 			hfmaxdelay = atoi(v->value);
@@ -3016,6 +3208,12 @@ static int load_settings(struct ast_conf
 				hfmaxdelay = DEFAULT_MAX_HOOKFLASH_DELAY;
 				ast_log(LOG_WARNING, "Incorrect hfmaxdelay '%s', defaulting to '%d'\n", v->value, hfmaxdelay);
 			}
+		} else if (!strcasecmp(v->name, "r4hanguptimeout")) {
+			r4hanguptimeout = atoi(v->value);
+			if (r4hanguptimeout > 30000 || r4hanguptimeout < 0) {
+				r4hanguptimeout = DEFAULT_R4_HANGUP_TIMEOUT;
+				ast_log(LOG_WARNING, "Incorrect r4hanguptimeout '%s', defaulting to '%d'\n", v->value, r4hanguptimeout);
+			}
 		}
 
 		v = v->next;
--- a/channels/chan_brcm.h
+++ b/channels/chan_brcm.h
@@ -42,6 +42,8 @@ enum channel_state {
 	RINGING,
 	CALLWAITING,
 	ONHOLD,
+	TRANSFERING,
+	RINGBACK,
 };
 
 enum endpoint_type {
@@ -70,7 +72,8 @@ struct brcm_subchannel {
 	unsigned int ssrc;		/* Endpoint RTP synchronization source */
 	int codec;			/* Used codec */
 	struct brcm_pvt *parent;	/* brcm_line owning this subchannel */
-	int timer_id;			/* Current timer id, -1 if no active timer*/
+	int cw_timer_id;			/* Current call waiting timer id, -1 if no active timer */
+	int r4_hangup_timer_id;		/* Current R4 hangup timer id, -1 if no active timer */
 };
 
 struct brcm_pvt {
@@ -181,6 +184,7 @@ typedef struct {
 	VRG_UINT32 jitterMin;
 	VRG_UINT32 jitterMax;
 	VRG_UINT32 jitterTarget;
+	int hangup_xfer;
 } line_settings;
 
 
@@ -207,7 +211,7 @@ static struct ast_jb_conf default_jbconf
 
 
 #define DEFAULT_CALL_WAITING_TIMEOUT 24 // In seconds, Telia uses 24s
-
+#define DEFAULT_R4_HANGUP_TIMEOUT 5000 // In milliseconds
 #define DEFAULT_MAX_HOOKFLASH_DELAY 500	// Max delay between early onhook and early offhook (in ms)
 
 
@@ -220,6 +224,7 @@ EPSTATUS vrgEndptProvGet( int line, EPPR
 EPSTATUS vrgEndptProvSet( int line, EPPROV provItemId, void* provItemValue, int provItemLength );
 
 static int cwtimeout_cb(const void *data);
+static int r4hanguptimeout_cb(const void *data);
 static void brcm_generate_rtp_packet(struct brcm_subchannel *p, UINT8 *packet_buf, int type);
 int brcm_create_connection(struct brcm_subchannel *p);
 static int brcm_mute_connection(struct brcm_subchannel *p);
@@ -227,6 +232,7 @@ static int brcm_unmute_connection(struct
 static int brcm_close_connection(struct brcm_subchannel *p);
 static int brcm_create_conference(struct brcm_pvt *p);
 static int brcm_stop_conference(struct brcm_subchannel *p);
+static int brcm_finish_transfer(struct brcm_subchannel *p, int result);
 int endpt_init(void);
 int endpt_deinit(void);
 void event_loop(void);
@@ -261,6 +267,8 @@ static int brcm_in_onhold(const struct b
 struct brcm_subchannel *brcm_get_idle_subchannel(const struct brcm_pvt *p);
 struct brcm_subchannel* brcm_get_active_subchannel(const struct brcm_pvt *p);
 static void brcm_subchannel_set_state(struct brcm_subchannel *sub, enum channel_state state);
+static int brcm_subchannel_is_idle(const struct brcm_subchannel const * const sub);
+static struct brcm_subchannel *brcm_subchannel_get_peer(const struct brcm_subchannel const * const sub);
 struct brcm_pvt* brcm_get_pvt_from_lineid(struct brcm_pvt *p, int line_id);
 void handle_dtmf(EPEVT event, struct brcm_subchannel *sub);
 
--- a/channels/chan_sip.c
+++ b/channels/chan_sip.c
@@ -1260,7 +1260,7 @@ static int transmit_info_with_aoc(struct
 static int transmit_info_with_digit(struct sip_pvt *p, const char digit, unsigned int duration);
 static int transmit_info_with_vidupdate(struct sip_pvt *p);
 static int transmit_message_with_text(struct sip_pvt *p, const char *text);
-static int transmit_refer(struct sip_pvt *p, const char *dest);
+static int transmit_refer(struct sip_pvt *p, const char *dest, const char *replaces);
 static int transmit_notify_with_mwi(struct sip_pvt *p, int newmsgs, int oldmsgs, const char *vmexten);
 static int transmit_notify_with_sipfrag(struct sip_pvt *p, int cseq, char *message, int terminate);
 static int transmit_cc_notify(struct ast_cc_agent *agent, struct sip_pvt *subscription, enum sip_cc_notify_state state);
@@ -6690,7 +6690,7 @@ static int sip_transfer(struct ast_chann
 	if (ast->_state == AST_STATE_RING)
 		res = sip_sipredirect(p, dest);
 	else
-		res = transmit_refer(p, dest);
+		res = transmit_refer(p, dest, NULL);
 	sip_pvt_unlock(p);
 	return res;
 }
@@ -7015,6 +7015,64 @@ static int sip_indicate(struct ast_chann
 		break;
 	case AST_CONTROL_UPDATE_RTP_PEER: /* Absorb this since it is handled by the bridge */
 		break;
+	case AST_CONTROL_TRANSFER_REMOTE:
+		if (datalen != sizeof(struct ast_transfer_remote_data)) {
+			ast_log(LOG_ERROR, "Invalid datalen for AST_CONTROL_TRANSFER_REMOTE. Expected %d, got %d\n", (int) sizeof(struct ast_transfer_remote_data), (int) datalen);
+			res = -1;
+		} else {
+			/* Construct replaces parameter to be added to Refer-To header */
+			const struct ast_transfer_remote_data *parameters = data;
+			//SIPBUFSIZE for callid. Half a SIPBUFSIZE for each tag and SIPBUFSIZE for parameter names (Replaces, to-tag, from-tag)
+			char replaces[SIPBUFSIZE + SIPBUFSIZE + SIPBUFSIZE];
+			replaces[0] = '\0';
+			if (parameters->replaces && strlen(parameters->replaces)) {
+				struct ast_channel *replaces_chan; //The channel that has the call that we're going to remotely replace
+				replaces_chan = ast_channel_get_by_name(parameters->replaces);
+				if (replaces_chan == NULL) {
+					ast_log(LOG_NOTICE, "Unable to fetch channel (%s) to be replaced. Refer-To header will be missing replaces-parameter\n", parameters->replaces);
+				} else {
+					ast_channel_lock(replaces_chan);
+
+					//Make sure this is a SIP channel too
+					if (!strcmp(replaces_chan->tech->type, ast->tech->type)) {
+
+						//Get info from SIP-dialog that we want to replace
+						struct sip_pvt *other_pvt = replaces_chan->tech_pvt;
+						if (other_pvt) {
+
+							//Get callid and tags from SIP dialog to replace
+							const char *callid = other_pvt->callid;
+							const char *totag;
+							const char *fromtag;
+
+							if (ast_test_flag(&other_pvt->flags[0], SIP_OUTGOING)) {
+								totag = other_pvt->theirtag;
+								fromtag = other_pvt->tag;
+							} else {
+								totag = other_pvt->theirtag;
+								fromtag = other_pvt->tag;
+							}
+
+							//Create uri encoded replaces parameter
+							//?Replaces=<callid>;to-tag=<totag>;from-tag=<fromtag>
+							char tmp[SIPBUFSIZE + SIPBUFSIZE + SIPBUFSIZE];
+							snprintf(replaces, sizeof(replaces), "%s;to-tag=%s;from-tag=%s", callid, totag, fromtag);
+							ast_uri_encode(replaces, tmp, sizeof(tmp), ast_uri_http);
+							snprintf(replaces, sizeof(replaces), "?Replaces=%s", tmp);
+						} else {
+							ast_log(LOG_WARNING, "Failed to get tech_pvt of replaces channel\n");
+						}
+					} else {
+						ast_log(LOG_NOTICE, "Asked to replace a call on channel type %s\n", replaces_chan->tech->type);
+					}
+					ast_channel_unlock(replaces_chan);
+				}
+			}
+
+			ast_log(LOG_DEBUG, "Transmitting refer\n");
+			res = transmit_refer(p, parameters->exten, replaces);
+		}
+		break;
 	case -1:
 		res = -1;
 		break;
@@ -13548,7 +13606,7 @@ static int sip_notify_allocate(struct si
 	engine whether a transfer succeeds or fails.
 	\todo Fix the transfer() dialplan function so that a transfer may fail
 */
-static int transmit_refer(struct sip_pvt *p, const char *dest)
+static int transmit_refer(struct sip_pvt *p, const char *dest, const char *replaces)
 {
 	struct sip_request req = {
 		.headers = 0,	
@@ -13588,9 +13646,9 @@ static int transmit_refer(struct sip_pvt
 		*c++ = '\0';
 	}
 	if (c) {
-		snprintf(referto, sizeof(referto), "<sip%s:%s@%s>", use_tls ? "s" : "", dest, c);
+		snprintf(referto, sizeof(referto), "<sip%s:%s@%s%s>", use_tls ? "s" : "", dest, c, replaces ? replaces : "");
 	} else {
-		snprintf(referto, sizeof(referto), "<sip%s:%s>", use_tls ? "s" : "", dest);
+		snprintf(referto, sizeof(referto), "<sip%s:%s%s>", use_tls ? "s" : "", dest, replaces ? replaces : "");
 	}
 
 	/* save in case we get 407 challenge */
@@ -18187,6 +18245,7 @@ static char *sip_show_settings(struct as
 		ast_cli(a->fd, "  SIP realtime:           Enabled\n" );
 	ast_cli(a->fd, "  Qualify Freq :          %d ms\n", global_qualifyfreq);
 	ast_cli(a->fd, "  Q.850 Reason header:    %s\n", AST_CLI_YESNO(ast_test_flag(&global_flags[1], SIP_PAGE2_Q850_REASON)));
+	ast_cli(a->fd, "  REFER await NOTIFY:     %s\n", AST_CLI_YESNO(sip_cfg.refer_await_notify));
 	ast_cli(a->fd, "  Store SIP_CAUSE:        %s\n", AST_CLI_YESNO(global_store_sip_cause));
 	ast_cli(a->fd, "\nNetwork QoS Settings:\n");
 	ast_cli(a->fd, "---------------------------\n");
@@ -20605,6 +20664,15 @@ static void handle_response_refer(struct
 		/* Now wait for next message */
 		ast_debug(3, "Got 202 accepted on transfer\n");
 		/* We should hang along, waiting for NOTIFY's here */
+
+		/* Some systems does not seem to send NOTIFY's, they just send BYE on dialog(s) after accepting the REFER */
+		if (!sip_cfg.refer_await_notify) {
+			if (p->owner) {
+				message = AST_TRANSFER_SUCCESS;
+				ast_queue_control_data(p->owner, AST_CONTROL_TRANSFER, &message, sizeof(message));
+				pvt_set_needdestroy(p, "received 202 response");
+			}
+		}
 		break;
 
 	case 401:   /* Not www-authorized on SIP method */
@@ -28152,6 +28220,7 @@ static int reload_config(enum channelrel
 	sip_cfg.peer_rtupdate = TRUE;
 	global_dynamic_exclude_static = 0;	/* Exclude static peers */
 	sip_cfg.tcp_enabled = FALSE;
+	sip_cfg.refer_await_notify = DEFAULT_REFERAWAITNOTIFY;
 
 	/* Session-Timers */
 	global_st_mode = SESSION_TIMER_MODE_ACCEPT;
@@ -28710,6 +28779,12 @@ static int reload_config(enum channelrel
 			ast_set2_flag(&global_flags[2], ast_true(v->value), SIP_PAGE3_SNOM_AOC);
 		} else if (!strcasecmp(v->name, "parkinglot")) {
 			ast_copy_string(default_parkinglot, v->value, sizeof(default_parkinglot));
+		} else if (!strcasecmp(v->name, "referawaitnotify")) {
+			if (ast_true(v->value)) {
+				sip_cfg.refer_await_notify = TRUE;
+			} else {
+				sip_cfg.refer_await_notify = FALSE;
+			}
 		}
 	}
 
--- a/channels/sip/include/sip.h
+++ b/channels/sip/include/sip.h
@@ -221,6 +221,7 @@
 #define DEFAULT_SDPOWNER   "root"          /*!< Default SDP username field in (o=) header unless re-defined in sip.conf */
 #define DEFAULT_ENGINE     "asterisk"      /*!< Default RTP engine to use for sessions */
 #define DEFAULT_CAPABILITY (AST_FORMAT_ULAW | AST_FORMAT_TESTLAW | AST_FORMAT_ALAW | AST_FORMAT_GSM | AST_FORMAT_H263);
+#define DEFAULT_REFERAWAITNOTIFY	FALSE
 #define DEFAULT_STORE_SIP_CAUSE FALSE      /*!< Don't store HASH(SIP_CAUSE,<channel name>) for channels by default */
 #endif
 /*@}*/
@@ -712,6 +713,7 @@ struct sip_settings {
 	format_t capability;        /*!< Supported codecs */
 	int tcp_enabled;
 	int default_max_forwards;    /*!< Default max forwards (SIP Anti-loop) */
+	int refer_await_notify;      /*!< Wait for NOTIFYs befor indicating transfer outcome */
 };
 
 /*! \brief The SIP socket definition */
--- a/include/asterisk/frame.h
+++ b/include/asterisk/frame.h
@@ -40,6 +40,15 @@ struct ast_codec_pref {
 	int framing[64]; /*!< Magic numbers are bad, but this just needs to be bigger than ARRAY_LEN(AST_FORMAT_LIST) */
 };
 
+
+/*
+ * For use with AST_CONTROL_TRANSFER_REMOTE
+ */
+struct ast_transfer_remote_data {
+	char exten[80]; /* extension to transfer to. TODO This should use AST_MAX_EXTENSION */
+	char replaces[AST_CHANNEL_NAME]; /* name of channel that is being replaced (if any) */
+};
+
 /*!
  * \page Def_Frame AST Multimedia and signalling frames
  * \section Def_AstFrame What is an ast_frame ?
@@ -336,6 +345,7 @@ enum ast_control_frame_type {
 	AST_CONTROL_END_OF_Q = 29,		/*!< Indicate that this position was the end of the channel queue for a softhangup. */
 	AST_CONTROL_INCOMPLETE = 30,	/*!< Indication that the extension dialed is incomplete */
 	AST_CONTROL_UPDATE_RTP_PEER = 31, /*!< Interrupt the bridge and have it update the peer */
+	AST_CONTROL_TRANSFER_REMOTE = 32, /*!< Indicate that network should transfer call (e.g. sip refer) */
 };
 
 enum ast_frame_read_action {
--- a/main/channel.c
+++ b/main/channel.c
@@ -4287,6 +4287,7 @@ static int attribute_const is_visible_in
 	case AST_CONTROL_CONNECTED_LINE:
 	case AST_CONTROL_REDIRECTING:
 	case AST_CONTROL_TRANSFER:
+	case AST_CONTROL_TRANSFER_REMOTE:
 	case AST_CONTROL_T38_PARAMETERS:
 	case _XXX_AST_CONTROL_T38:
 	case AST_CONTROL_CC:
@@ -7098,6 +7099,8 @@ static enum ast_bridge_result ast_generi
 			case AST_CONTROL_SRCUPDATE:
 			case AST_CONTROL_SRCCHANGE:
 			case AST_CONTROL_T38_PARAMETERS:
+			case AST_CONTROL_TRANSFER_REMOTE:
+			case AST_CONTROL_TRANSFER:
 				ast_indicate_data(other, f->subclass.integer, f->data.ptr, f->datalen);
 				if (jb_in_use) {
 					ast_jb_empty_and_reset(c0, c1);
